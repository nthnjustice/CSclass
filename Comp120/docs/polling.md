#Leg 6: Polling and Memory Caching

##Polling

Our solution to the polling problem was to use simple ajax requests. The polling request queries the server's database every 15 seconds for new posts. Although 15 seconds might seem excessive, we decided that given the immediate attention needed for potential "emergencies", it's better from a practical standpoint that the requests are sent more often then not. The amount of time between polls may change if reloading a large number incident reports dramatically decreases the application's performance. The ajax requests are written using the setTimeout() function so that the next ajax request is made only after the one before it has completed. This way, if a request is taking a long time, we won't get a huge back up of several requests to our server.

We chose this simple solution over something like websockets for several reasons. For our purposes, we do not need real time updates so web sockets are unneccessary. The implementation of ajax requests is much more simple than writing the code to implement web socket connections which we don't know much about. As for drawbacks to our decision, there are a few: The posts will be refreshed every 15 seconds, as long as a user has our website open. Regardless of whether a user is active on our page, the polling will occur. Also, if no new posts are made for a few hours, then we are doing a lot of 'wasteful' queries to our server. However, in our current situation this does not seem like a huge issue given the small number of users that will be on our site. If in the future our user base expands and our servers are struggling to handle the load, we will look into something like web sockets.

When a polling request is sent to our server, it is directed via a routing method to execute an action in the static_pages controller called "polling". This action does two things: 1) refreshes the global report-feed's queried content with all of the reports in the database, bypassing the cache to ensure all new and updated reports are returned to the user and 2) the action executes a javascript file that refreshes the partial that renders the global report-feed. Our implementation is advantageous in that a polling request does not reload the entire page, but just the dynamic content embedded in the page. This design enhances the efficiency of our polling feature by reducing the amount of data retrieved from the server to the bare minimum.

Currently we reload all of the posts with each ajax request, but in the immediate future we plan to refine the feature to only reload the global report-feed if a new one has been stored or if an old report has been updated. This will again enhance the efficiency of our application by reducing the amount of redundant data retrieved from the server. 

##Caching

For our caching solution we used Memcached. We chose to use memcached because it seemed like there is a ton of documentationon using Memcached with Rails. Also, there is a readily available heroku addon called "Memcached Cloud", which we used to enable caching in production. Additionally, the Memcached Cloud addon has nifty data tracking features that helps us assess the amount of data cached by our users. Redis offers data persistence, but we did not see this feature as something that outweighed the steeper learning curve and available information on using Memcached with Rails.

To implement caching, all we were required to do was update the config file, add the dalli gem, and insert a few lines of code in the app to change a database query to a cache fetch. The cache fetch method is very slick because it first searches the cache for available data, if there is nothing in the cache, the fetch method then queries the database and stores the query in the cache. That is to say, the fetch method executes both read and write methods in the appropriate order (the order being, 1) check the cache, and if the cache is empty 2) check the database). Our current implementation caches all of the incident reports. Additionally, we have implemented a session-storage feature that uses caching and cookie-storage for log-in information for activated users who wish to remain logged in on the app even after closing the browser. 